diff --git a/supabase/migrations/20250923_create_receipts.sql b/supabase/migrations/20250923_create_receipts.sql
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/supabase/migrations/20250923_create_receipts.sql
@@
+-- Migration: create receipts table (idempotent)
+-- Run via Supabase migrations or paste into Supabase SQL Editor (dev)
+BEGIN;
+
+CREATE TABLE IF NOT EXISTS public.receipts (
+  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+  type TEXT NOT NULL CHECK (type IN ('Decision-RDS','Consent-RDS','Settlement-RDS','Delta-RDS','Vault-RDS','Comms-RDS')),
+  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
+  org_id UUID,
+  tenant_id UUID,
+  inputs_hash TEXT NOT NULL,
+  policy_version TEXT NOT NULL,
+  result TEXT,
+  reasons TEXT[],
+  payload JSONB NOT NULL DEFAULT '{}'::jsonb,
+  canonical_safe JSONB,          -- PII-free canonical snapshot
+  sha256_hash TEXT NOT NULL,
+  anchor_ref JSONB,
+  anchor_status TEXT NOT NULL DEFAULT 'pending' CHECK (anchor_status IN ('pending','anchored','failed')),
+  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
+  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
+);
+
+CREATE INDEX IF NOT EXISTS idx_receipts_user_id ON public.receipts (user_id);
+CREATE INDEX IF NOT EXISTS idx_receipts_org_id ON public.receipts (org_id);
+CREATE INDEX IF NOT EXISTS idx_receipts_type ON public.receipts (type);
+CREATE INDEX IF NOT EXISTS idx_receipts_created_at ON public.receipts (created_at DESC);
+CREATE INDEX IF NOT EXISTS idx_receipts_anchor_pending ON public.receipts (created_at) WHERE anchor_status = 'pending';
+
+ALTER TABLE public.receipts ENABLE ROW LEVEL SECURITY;
+
+-- policies: owner read/insert (service roles handled below)
+CREATE POLICY IF NOT EXISTS receipts_select_owner ON public.receipts
+  FOR SELECT USING (user_id IS NULL OR auth.uid() = user_id);
+
+CREATE POLICY IF NOT EXISTS receipts_insert_owner ON public.receipts
+  FOR INSERT WITH CHECK (user_id IS NULL OR auth.uid() = user_id);
+
+-- service role update (anchor worker). Requires service token with jwt.claims.role = 'service'
+CREATE POLICY IF NOT EXISTS receipts_service_update ON public.receipts
+  FOR UPDATE USING (current_setting('jwt.claims.role', true) = 'service')
+  WITH CHECK (current_setting('jwt.claims.role', true) = 'service');
+
+-- trigger to keep updated_at fresh
+CREATE OR REPLACE FUNCTION public.update_receipts_updated_at()
+RETURNS TRIGGER AS $$
+BEGIN
+  NEW.updated_at = NOW();
+  RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+DROP TRIGGER IF EXISTS receipts_updated_at ON public.receipts;
+CREATE TRIGGER receipts_updated_at
+  BEFORE UPDATE ON public.receipts
+  FOR EACH ROW EXECUTE FUNCTION public.update_receipts_updated_at();
+
+COMMIT;
diff --git a/supabase/migrations/20250923_create_receipts_rollback.sql b/supabase/migrations/20250923_create_receipts_rollback.sql
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/supabase/migrations/20250923_create_receipts_rollback.sql
@@
+-- Rollback for receipts migration
+BEGIN;
+DROP TRIGGER IF EXISTS receipts_updated_at ON public.receipts;
+DROP FUNCTION IF EXISTS public.update_receipts_updated_at();
+DROP TABLE IF EXISTS public.receipts CASCADE;
+COMMIT;
diff --git a/src/lib/db/safeSupabase.ts b/src/lib/db/safeSupabase.ts
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/lib/db/safeSupabase.ts
@@
+import { supabase } from '@/integrations/supabase/client';
+const isDev = import.meta.env.MODE === 'development';
+
+export async function tableExists(name: string): Promise<boolean> {
+  try {
+    // head query to test existence
+    const q: any = (supabase as any).from(name).select('id', { head: true, count: 'exact' }).limit(1);
+    const res = await q;
+    return !res.error;
+  } catch (e) {
+    if (isDev) console.warn(`[tableExists] ${name}`, e);
+    return false;
+  }
+}
+
+export async function safeSelect<T = any>(
+  table: string,
+  select = '*',
+  opts?: { limit?: number; order?: { column: string; ascending?: boolean } }
+): Promise<{ ok: boolean; data?: T[]; error?: any }> {
+  try {
+    let q: any = (supabase as any).from(table).select(select);
+    if (opts?.order) q = q.order(opts.order.column, { ascending: !!opts.order.ascending });
+    if (opts?.limit) q = q.limit(opts.limit);
+    const { data, error } = await q;
+    if (error) throw error;
+    return { ok: true, data };
+  } catch (err) {
+    if (isDev) console.warn(`[safeSelect] ${table}`, err);
+    return { ok: false, error: err };
+  }
+}
+
+export async function safeInsert(table: string, rows: any | any[]) {
+  try {
+    const { data, error } = await (supabase as any).from(table).insert(rows).select();
+    if (error) throw error;
+    return { ok: true, data };
+  } catch (err) {
+    if (isDev) console.warn(`[safeInsert] ${table}`, err);
+    return { ok: false, error: err };
+  }
+}
+
+export async function safeUpdate(table: string, patch: any, match: Record<string, any>) {
+  try {
+    const { data, error } = await (supabase as any).from(table).update(patch).match(match).select();
+    if (error) throw error;
+    return { ok: true, data };
+  } catch (err) {
+    if (isDev) console.warn(`[safeUpdate] ${table}`, err);
+    return { ok: false, error: err };
+  }
+}
+
+export async function withFallback<T>(
+  table: string,
+  query: () => Promise<{ ok: boolean; data?: T[] }>,
+  fallback: () => Promise<T[]> | T[]
+): Promise<T[]> {
+  const exists = await tableExists(table);
+  if (!exists) return await Promise.resolve(fallback());
+  const res = await query();
+  if (!res.ok || !res.data) return await Promise.resolve(fallback());
+  return res.data!;
+}
+
+// emitReceipt helper: canonicalize externally, pass PII-free snapshot as canonical_safe
+export async function emitReceipt(params: {
+  type: string;
+  user_id?: string | null;
+  org_id?: string | null;
+  inputs_hash: string;
+  policy_version: string;
+  payload?: any;
+  canonical_safe?: any;
+}) {
+  const row = {
+    type: params.type,
+    user_id: params.user_id ?? null,
+    org_id: params.org_id ?? null,
+    inputs_hash: params.inputs_hash,
+    policy_version: params.policy_version,
+    payload: params.payload ?? {},
+    canonical_safe: params.canonical_safe ?? null,
+    sha256_hash: params.inputs_hash,
+  };
+  return safeInsert('receipts', row);
+}
diff --git a/src/lib/mocks/leads.mock.ts b/src/lib/mocks/leads.mock.ts
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/lib/mocks/leads.mock.ts
@@
+export type Lead = {
+  id: string; email: string; first_name?: string; last_name?: string; stage?: string; created_at?: string;
+};
+export const mockLeads: Lead[] = [
+  { id: 'L-001', email: 'sam@example.com', first_name: 'Sam', last_name: 'Taylor', stage: 'new', created_at: new Date().toISOString() },
+  { id: 'L-002', email: 'alex@example.com', first_name: 'Alex', last_name: 'Chen', stage: 'engaged', created_at: new Date().toISOString() }
+];
diff --git a/src/lib/mocks/advisors.mock.ts b/src/lib/mocks/advisors.mock.ts
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/lib/mocks/advisors.mock.ts
@@
+export type Advisor = { id: string; name: string; email: string; firm?: string; created_at?: string; };
+export const mockAdvisors: Advisor[] = [
+  { id: 'A-001', name: 'Jordan Lee', email: 'jordan@firm.co', firm: 'Creator Advisory', created_at: new Date().toISOString() },
+  { id: 'A-002', name: 'Riley Perez', email: 'riley@firm.co', firm: 'NIL Partners', created_at: new Date().toISOString() }
+];
diff --git a/src/components/common/FallbackBanner.tsx b/src/components/common/FallbackBanner.tsx
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/components/common/FallbackBanner.tsx
@@
+import React from 'react';
+
+export default function FallbackBanner({ table }: { table: string }) {
+  return (
+    <aside className="mb-3 rounded-md bg-yellow-50 p-3 text-sm text-yellow-800 border border-yellow-200">
+      Feature disabled in this environment — table <code className="font-mono">{table}</code> not found.
+      Showing read-only mock data.
+    </aside>
+  );
+}
diff --git a/src/components/admin/diagnostics/WebhookRouteCheck.tsx b/src/components/admin/diagnostics/WebhookRouteCheck.tsx
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/components/admin/diagnostics/WebhookRouteCheck.tsx
@@
+import React from 'react';
+
+function StatusPill({ status }: { status: 'GREEN'|'YELLOW'|'RED' }) {
+  const cls = status === 'GREEN' ? 'bg-green-600' : status === 'YELLOW' ? 'bg-yellow-500' : 'bg-red-600';
+  return <span className={`inline-block w-3 h-3 rounded-full ${cls}`} />;
+}
+
+export default function WebhookRouteCheck() {
+  const [status, setStatus] = React.useState<'GREEN'|'RED'|'YELLOW'>('YELLOW');
+  const [code, setCode] = React.useState<number | null>(null);
+
+  async function run() {
+    try {
+      const res = await fetch('/api/stripe/webhook', { method: 'HEAD' });
+      setCode(res.status);
+      setStatus(res.status === 200 || res.status === 405 ? 'GREEN' : 'RED');
+    } catch {
+      setCode(null);
+      setStatus('RED');
+    }
+  }
+
+  React.useEffect(() => { run(); }, []);
+
+  return (
+    <div className="rounded-lg border p-4">
+      <div className="flex items-center justify-between mb-2">
+        <h3 className="text-sm font-semibold">Stripe Webhook Route</h3>
+        <button className="text-xs underline" onClick={run}>Run again</button>
+      </div>
+      <div className="flex items-center gap-2">
+        <StatusPill status={status} />
+        <span className="text-xs text-muted">HEAD /api/stripe/webhook — status {code ?? '—'}</span>
+      </div>
+    </div>
+  );
+}
diff --git a/src/context/AuthContext.tsx b/src/context/AuthContext.tsx
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/src/context/AuthContext.tsx
@@
+'use client';
+import React, { createContext, useState, useEffect } from 'react';
+import { withFallback, safeSelect } from '@/lib/db/safeSupabase';
+
+export const AuthContext = createContext(null);
+
+export function AuthProvider({ children }: { children: React.ReactNode }) {
+  const [userProfile, setUserProfile] = useState<any>(null);
+
+  useEffect(() => {
+    let mounted = true;
+    (async () => {
+      const rows = await withFallback(
+        'profiles',
+        () => safeSelect('profiles', '*', { limit: 1 }),
+        async () => []
+      );
+      if (!mounted) return;
+      setUserProfile((rows && rows[0]) || null);
+    })();
+    return () => { mounted = false; };
+  }, []);
+
+  return <AuthContext.Provider value={{ userProfile }}>{children}</AuthContext.Provider>;
+}
diff --git a/scripts/wrap-risky-tables.js b/scripts/wrap-risky-tables.js
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/scripts/wrap-risky-tables.js
@@
+// Helper: scan source files and warn about direct supabase.from('profiles'|'leads'|'advisor_profiles')
+// This script is a suggestion helper — inspect diffs before committing.
+const fs = require('fs');
+const path = require('path');
+const glob = require('glob');
+
+const TARGET_TABLES = ['leads','profiles','advisor_profiles'];
+
+function processFile(file) {
+  let s = fs.readFileSync(file,'utf8');
+  let orig = s;
+  TARGET_TABLES.forEach(tbl => {
+    const readRegex = new RegExp(`supabase\\.from\\(['"\`]${tbl}['"\`]\\)\\.select\\(`, 'g');
+    s = s.replace(readRegex, `/* wrapped: use safeSelect/withFallback */`);
+  });
+  if (s !== orig) {
+    fs.writeFileSync(file, s, 'utf8');
+    console.log('patched', file);
+  }
+}
+
+const files = glob.sync('src/**/*.@(ts|tsx|js|jsx)');
+files.forEach(processFile);
+console.log('done');
