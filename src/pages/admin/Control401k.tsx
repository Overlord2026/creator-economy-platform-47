import React, { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";
import { initReceiptsEmitterAuto, hashActionRequest } from "@/lib/receiptsEmitter";
import { runPlanBenchmark } from "@/lib/401k/planBenchmark";
import { evalAdvGate } from "@/lib/401k/pteGate";

/**
 * 401k Control Plane — admin console
 * Buttons:
 * - Run Plan Benchmark -> emits pre/post receipts with Plan_Benchmark_Receipt + FeeCompare_RDS
 * - Emit PTE Advice Chain -> records AdviceSummary_RDS, Delivery_RDS, Settlement_RDS (advice-only)
 * - Test %ADV Gate -> emits pre receipt with ALLOW_WITH_CONDITIONS or DENY and ADV_Gate fields
 * - Replay Verify -> calls RPC to confirm a receipt's status (anchor, policies, request_hash)
 * 
 * Mirrors your provisional spec: inputs_hash → plan_benchmark_receipt; PTE 2020-02 advice chain; %ADV cap; anchored receipts; replay.verify.
 */

type ReceiptRow = { id: string; stage: "pre"|"post"; created_at: string; decision: string; request_hash: string; anchor_status: string; };

export default function Control401k() {
  const [rows,setRows] = useState<ReceiptRow[]>([]);
  const [err,setErr] = useState<string|null>(null);
  const [busy,setBusy] = useState(false);
  const [lastId,setLastId] = useState<string | null>(null);

  async function refresh() {
    const { data, error } = await supabase
      .from("receipts")
      .select("id,stage,created_at,decision,request_hash,anchor_status")
      .order("created_at",{ascending:false})
      .limit(50);
    if (error) setErr(error.message); else setRows((data||[]) as ReceiptRow[]);
  }
  useEffect(()=>{ refresh(); },[]);

  async function emitBenchmark() {
    try {
      setBusy(true);
      const emitter = initReceiptsEmitterAuto(supabase);
      const bench = await runPlanBenchmark();
      const action = { kind: "401k_benchmark", inputs_hash: bench.inputs_hash };
      const request_hash = await hashActionRequest(action);

      // Pre: decision after rules evaluation (allow_with_conditions to reflect PTE chain)
      const pre = await emitter.emitPre({
        request_hash,
        decision: "ALLOW_WITH_CONDITIONS",
        policies: [{ bundle_id: "rs://401k@current" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "advisor", ts: new Date().toISOString() }],
      });

      // Post: include FeeCompare_RDS + Plan_Benchmark_Receipt as content-free effects
      await emitter.emitPost({
        request_hash,
        decision: "ALLOW_WITH_CONDITIONS",
        policies: [{ bundle_id: "rs://401k@current" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "advisor", ts: new Date().toISOString() }],
        effects: [
          { type: "FeeCompare_RDS", value: bench.FeeCompare_RDS },
          { type: "Plan_Benchmark_Receipt", value: bench.Plan_Benchmark_Receipt }
        ],
        linked_receipt_id: pre.id,
      });

      await refresh();
      setLastId(pre.id);
      alert("Plan benchmark receipts emitted.");
    } catch (e:any) { alert(e.message || String(e)); } finally { setBusy(false); }
  }

  async function emitAdviceChain() {
    try {
      setBusy(true);
      const emitter = initReceiptsEmitterAuto(supabase);
      const action = { kind: "pte_2020_02_advice_only" };
      const request_hash = await hashActionRequest(action);

      const pre = await emitter.emitPre({
        request_hash,
        decision: "ALLOW_WITH_CONDITIONS",
        policies: [{ bundle_id: "rs://401k@pte2020-02" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "advisor", ts: new Date().toISOString() }],
      });

      await emitter.emitPost({
        request_hash,
        decision: "ALLOW_WITH_CONDITIONS",
        policies: [{ bundle_id: "rs://401k@pte2020-02" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "advisor", ts: new Date().toISOString() }],
        effects: [
          { type: "AdviceSummary_RDS", value: { pte: "2020-02", advice_only: true, rule_version: "2025-09-01" } },
          { type: "Delivery_RDS", value: { instructions: ["reduce share class fees","rebid recordkeeper"], advice_only: true } },
          { type: "Settlement_RDS", value: { status: "executed", lineage: ["AdviceSummary_RDS","Delivery_RDS"] } }
        ],
        linked_receipt_id: pre.id,
      });

      await refresh();
      setLastId(pre.id);
      alert("PTE 2020-02 advice-only chain recorded.");
    } catch (e:any) { alert(e.message || String(e)); } finally { setBusy(false); }
  }

  async function testAdvGate() {
    try {
      setBusy(true);
      const emitter = initReceiptsEmitterAuto(supabase);
      const gate = evalAdvGate();
      const action = { kind: "adv_cap_gate_test" };
      const request_hash = await hashActionRequest(action);

      const pre = await emitter.emitPre({
        request_hash,
        decision: gate.decision as any,
        policies: [{ bundle_id: "rs://401k@adv_cap" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "supervisor", ts: new Date().toISOString() }],
      });

      await emitter.emitPost({
        request_hash,
        decision: gate.decision as any,
        policies: [{ bundle_id: "rs://401k@adv_cap" }],
        approvals: [{ signer: (await supabase.auth.getUser()).data?.user?.id || "me", role: "supervisor", ts: new Date().toISOString() }],
        effects: [{ type: "ADV_Gate", value: gate.ADV_Gate }, { type: "GateReasons", value: gate.reasons }],
        linked_receipt_id: pre.id,
      });

      await refresh();
      setLastId(pre.id);
      alert("%ADV gate evaluated and logged.");
    } catch (e:any) { alert(e.message || String(e)); } finally { setBusy(false); }
  }

  async function replayVerify() {
    try {
      setBusy(true);
      const id = lastId || rows.find(r=>r.stage==="pre")?.id;
      if (!id) { alert("No recent receipt id"); setBusy(false); return; }
      const { data, error } = await supabase.rpc("replay_verify", { p_receipt: id });
      if (error) throw error;
      alert(JSON.stringify(data, null, 2));
    } catch (e:any) { alert(e.message || String(e)); } finally { setBusy(false); }
  }

  return (
    <div className="p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-semibold">401k Control Plane</h2>
        <div className="flex gap-2">
          <button className="px-3 py-2 rounded bg-black text-white disabled:opacity-50" onClick={emitBenchmark} disabled={busy}>Run Plan Benchmark</button>
          <button className="px-3 py-2 rounded bg-black text-white disabled:opacity-50" onClick={emitAdviceChain} disabled={busy}>Emit PTE Advice Chain</button>
          <button className="px-3 py-2 rounded bg-black text-white disabled:opacity-50" onClick={testAdvGate} disabled={busy}>Test %ADV Gate</button>
          <button className="px-3 py-2 rounded bg-black text-white disabled:opacity-50" onClick={replayVerify} disabled={busy}>Replay Verify</button>
        </div>
      </div>

      {err && <div className="text-red-600 mb-3">{err}</div>}
      <table className="min-w-full text-sm">
        <thead><tr className="text-left border-b">
          <th className="py-2 pr-4">ID</th><th className="py-2 pr-4">Stage</th><th className="py-2 pr-4">Decision</th><th className="py-2 pr-4">Anchor</th><th className="py-2 pr-4">Created</th>
        </tr></thead>
        <tbody>
          {rows.map(r=>(
            <tr key={r.id} className="border-b">
              <td className="py-2 pr-4">{r.id.slice(0,8)}…</td>
              <td className="py-2 pr-4">{r.stage}</td>
              <td className="py-2 pr-4">{r.decision}</td>
              <td className="py-2 pr-4">{r.anchor_status}</td>
              <td className="py-2 pr-4">{new Date(r.created_at).toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}